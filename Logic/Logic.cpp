#include <iostream>
#include <locale.h>
#include <stdlib.h>

using namespace std;

int main()
{
	setlocale(LC_ALL, "rus");
	int A = 0, B = 10, C = 0;

	cout << "Введите переменную С: ";
	cin >> C;

	/* (!) if (A < C < B) так писать нельзя! Т.к. эти два действия будут выполняться последовательно, т.е. сначала будет выполнена операция сравнения А и С (A<C), а по-
	том будет выполнена операция сравнения результата этого сравнения (1/0) с переменной В. И т.о. у нас всегда будет истина. В программировании нам необходимо их раз-
	делить на 2 действия и потом объединить при помощи операторов объединения. Операций логического объединения всего 2:

		1. логическое умножение или логическая операция 'И' (коньюнкция)
		   Рассмотрим варианты возможных комбинаций
		   (A<C)  (C<B)   'И'
			 X      Y     X&&Y
			 1		1	    1		(как и при умножении, коньюнкция даст истину (1) только когда ОБА выражения дадут истину!)
			 1		0	    0
			 0		1       0
			 0		0       0

		2. логическое сложение или логическая операция 'ИЛИ' (дидьюнкция)
		   Рассмотрим варианты возможных комбинаций
		   (A<C)  (C<B)  'ИЛИ'
			 X      Y     X||Y
			 1		1	    1		(как и при сложении, дидьюнкция даст истину (1) только когда ХОТЯ БЫ ОДНО ИЗ выражений даст истину!)
			 1		0	    1
			 0		1       1
			 0		0       0

		3. логическое отрицание или логическая операция 'НЕ' (инверсия) - унарная операция (имеет только один операнд)
		   Меняет лог.значение на противоположное:
			 X     !Х
			 1		0
			 0		1

	Данные три конструкции позволяют построить логические выражения люб.сложности! Под ними кроется физ.основа, а именно транзисторные сборки, т.е.как это устроено в
	оборудовании. Мы всеми сложными выражениями или простыми подводим к правде и ложи, а транзисторы реализуют из на уровне сигналов и напряжений
	AND		NotAnd	=	NAND
	OR		NotOr	=	NOR
	NOT
	(Вся опер.память у нас бывает двух видов: NOR и NAND. Разница в объеме с скорости. Одна большого объема, но медленная, другая маленького объема, на быстрая. И раз-
	личаются они тем, на каких логических элементах построены, последовательное или параллельное подключение.

	Касаемо приоритета выполнения. Операции && и || имеют равный приоритет и выполняются последовательно, но они разные. Скобки для них ((A<C)&&(C<B)) можно не ставить,
	но в сложных выражениях нужно самим, при помощи скобок, выбирать что должно быть выполнено в первую очередь, скажем, выражение A&&B||C будет выполнено по порядку, а
	выражение A&&(B||C) нет. За этим нужно следить в зависимости от поставленной задачи. */

	/*
	if (A < C && C < B)
	{
		cout << "Ура! Переменная С имеет нужное значение!" << endl;			// если значение С от 0 до 10
	}
	else
	{
		cout << "Переменная С не удовлетворяет условию!" << endl;
	}
	*/

	cout << "Введите переменную А: "; cin >> A;

	/* Рассмотрим на практике:

		1. если А четное 'ИЛИ' А < 1000, запишем в коде:
	if (A % 2 == 0 || A < 1000)
	У нас у сложного выражения истина получится в 3-х случаях, когда оба выражения дадут истину или одно из них даст истину, а другой ложь.

		2. если А четное 'И' А < 1000:
	if (A % 2 == 0 && A < 1000)
	У нас у сложного выражения истина получится только в 1-м случае, когда оба выражения дадут истину! (когда А четное и А меньше 1000)	*/

	if (A % 2 == 0 && A < 1000)
		cout << "Число А: " << A << endl;
	else
		cout << "Переменная А не удовлетворяет условию!" << endl;

	/* Логическое отрицание или логическая операция 'НЕ' (инверсия)
	Заменяет истину на ложь, а ложь на истину. Так что же есть истина, а что есть ложь? Рассмотрим два самых вероятных варианта использования 'НЕ':

		1. мы обращаем выражение:
		!(A < C)
		Это словно если бы мы написали (A>=C). Если выражение A < C даст ложь (0), то условие станет истиной (1) и наоборот.

		2. мы обращаем переменную:
		!A < C
		Сначала будет взято обратное значение переменной А, а потом произойдет сравнение с переменной С. В этом случае НЕ ПРОИЗОЙДЕТ запись значения переменной с проти-
		воположным знаком, а случится следующее - т.к. это ЛОГИЧЕСКОЕ отрицание, то произойдет ЛОГИЧЕСКАЯ инверсия данной переменной, из истины в ложь или же изо лжи в
		истину. След, 1-м делом произойдет преобразование переменной в тип данных bool, а потом ее логическое значение будет инвертировано, из истины в ложь и наоборот.
		(!) Как произойдет преобразование переменной из целочисленного int в логической bool?
		Т.к. int старше bool, то произойдет сужающее преобразование к bool с потерей данный до 1 либо до 0 по след. логике:
		0 это всегда ложь, а любое число отличное от нуля станет 1.
		Если переменная А неравна 0, то она преобразуется в 1 (истину), а потом инвертируется в 0 (ложь). А ложь это 0, след, мы в итоге будем сравать 0 с переменной С.
		Или же наоборот, если переменная А равна 0, то она преобразуется в лог.ноль и инвертируется в лог.единицу (истину), и мы 1-цу будем сравнивать с переменной С.
		 */

	if (!(A < C))
		cout << "А не меньше С!" << endl;

	if (!A < C)											// так писать некорректно, т.к. у нас сравниваются разные типы данных, но это может быть использованно ниже
		cout << "Не А меньше С!" << endl;

	/* (!) Мы попадем в блок if else не только когда в скобках этого блока есть неравеноство с несколькими переменными, а когда значение скобок блока обращается в исти-
	ну. Оно всегда обращается в истину или ложь независимо есть ли у нас там сравнения (при помощи операторов сравнения) одной переменной с другой или нет. Рассмотрим
	логику важного действия ниже:
							  А     !А
	любое число кроме нуля == 1		 0
	0 обращается лишь в лог.  0		 1

	Т.о. мы лог.операцию ниже можем использовать на проверку переменной на равенство 0.
	Если А равно 0, то она обернется в лог.нуль (ложь), инвертируясь обернется истиной (1) и попадет в блок if else. В учебниках это запись называется "Если А существу-
	ет" или А неравно нулю.
	(!) Лог.операции не изменяют сами значения переменных, а только проводят сравнения! */

	if (!A)												// if(A==0)		[если А существует (А отличная от нуля)]
		cout << "Переменная А равна нулю!" << endl;
}